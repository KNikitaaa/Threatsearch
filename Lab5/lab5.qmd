---
title: "Исследование информации о состоянии беспроводных сетей"
author: "niki-tos29@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы

  1. Получить знания о методах исследования радиоэлектронной обстановки.
  2. Составить представление о механизмах работы Wi-Fi сетей на канальном и
сетевом уровне модели OSI.
  3. Закрепить практические навыки использования языка программирования R для
обработки данных
  4. Закрепить знания основных функций обработки данных экосистемы tidyverse
языка R


## Исходные данные

1. Программное обеспечение Windows 11 Pro
2. Rstudio Desktop
3. Интерпретатор языка R 4.5.1
4. Программный пакет dplyr
5. Журналы программных средств анализа беспроводных сетей – tcpdump и airodump-ng 
       
 
## План

1. Подготовка данных для анализа 
2. Анализ точек доступа
3. Анализ данных клиентов
4. Оформление отчета


## Шаги:  

### Подготовка данных


1.  Импортируйте данные.

```{r}
options(repos = c(CRAN = "https://mirror.truenetwork.ru/CRAN/"))
install.packages("dplyr")
library(tidyverse)
library(lubridate)
library(stringr)
url <- "https://storage.yandexcloud.net/dataset.ctfsec/P2_wifi_data.csv"
```

```{r}
raw_input <- read_csv(url, skip = 1, col_names = FALSE)
split_point <- which(raw_input$X1 == "Station MAC")
```

2. Привести датасеты в вид “аккуратных данных”, преобразовать типы столбцов в соответствии с типом данных.

```{r}
tbl_access <- raw_input[2:(split_point[1] - 1), ]
tbl_clients <- raw_input[split_point[1]:nrow(raw_input), ]

tbl_access <- tbl_access[rowSums(is.na(tbl_access)) < ncol(tbl_access), ]
tbl_clients <- tbl_clients[rowSums(is.na(tbl_clients)) < ncol(tbl_clients), ]

tbl_clients <- tbl_clients[, 1:7]

colnames_ap <- c(
  "bssid", "first_seen", "last_seen", "chan", "speed",
  "privacy", "cipher", "auth", "pwr", "beacon_count",
  "iv", "lan", "id_len", "essid", "key"
)

colnames_cl <- c(
  "mac", "first_seen", "last_seen", "pwr",
  "pkt", "bssid", "probe"
)

names(tbl_access) <- colnames_ap[1:ncol(tbl_access)]
names(tbl_clients) <- colnames_cl[1:ncol(tbl_clients)]

wifi_ap <- tbl_access %>%
  filter(!is.na(bssid), bssid != "", !is.na(essid), essid != "") %>%
  mutate(
    first_seen = as.POSIXct(first_seen, "%Y-%m-%d %H:%M:%S"),
    last_seen  = as.POSIXct(last_seen, "%Y-%m-%d %H:%M:%S"),
    chan   = as.numeric(chan),
    speed  = as.numeric(speed),
    pwr    = as.numeric(pwr),
    beacon_count = as.numeric(beacon_count),
    iv     = as.numeric(iv),
    id_len = as.numeric(id_len)
  )

wifi_cl <- tbl_clients[-1, ] %>%
  filter(!is.na(mac), mac != "", mac != "Station MAC") %>%
  mutate(
    first_seen = as.POSIXct(first_seen, "%Y-%m-%d %H:%M:%S"),
    last_seen  = as.POSIXct(last_seen, "%Y-%m-%d %H:%M:%S"),
    pwr = as.numeric(pwr),
    pkt = as.numeric(pkt)
  )
```

3. Просмотрите общую структуру данных с помощью функции glimpse()

```{r}
glimpse(wifi_ap)
glimpse(wifi_cl)
```

### Анализ

```{r}
extract_oui <- function(mac_addr) {
  mac_addr %>%
    { ifelse(!is.na(.) & . != "", str_replace_all(substr(., 1, 8), ":", "-"), NA_character_) }
}
```

1. Определить небезопасные точки доступа (без шифрования – OPN).

``` {r}
open_ap <- wifi_ap %>%
  filter(privacy == "OPN") %>%
  arrange(desc(pwr)) %>%
  select(bssid, essid, privacy, pwr, chan)
```

``` {r}
if (nrow(open_ap) > 0) {
  print(open_ap)
  cat("Всего небезопасных точек доступа:", nrow(open_ap), "\n")
  cat("Процент от общего числа:",
      round(100 * nrow(open_ap) / nrow(wifi_ap), 1), "%\n")
} else {
  cat("Небезопасные точки доступа отсутствуют.\n")
}
```

2. Определить производителя для каждого обнаруженного устройства.

``` {r}
ap_vendor <- wifi_ap %>%
  mutate(vendor = extract_oui(bssid)) %>%
  select(bssid, essid, vendor, privacy, pwr)

vendor_count <- ap_vendor %>%
  count(vendor, name = "n") %>%
  arrange(desc(n))
```

``` {r}
print(head(vendor_count, 10))
cat("Количество уникальных производителей:",
    n_distinct(ap_vendor$vendor, na.rm = TRUE), "\n")
```

3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах.

```{r}
wpa3_set <- wifi_ap %>%
  filter(
    str_detect(toupper(coalesce(auth, "")), "WPA3") |
    str_detect(toupper(coalesce(privacy, "")), "WPA3") |
    str_detect(toupper(coalesce(cipher, "")),  "WPA3")
  ) %>%
  arrange(desc(pwr)) %>%
  select(bssid, essid, privacy, auth, cipher, pwr)
```

``` {r}
if (nrow(wpa3_set) > 0) {
  print(wpa3_set)
  cat("Всего устройств с WPA3:", nrow(wpa3_set), "\n")
} else {
  cat("Устройства с WPA3 не найдены.\n")
}
```

4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.

``` {r}
ap_sessions <- wifi_ap %>%
  group_by(bssid) %>%
  arrange(first_seen) %>%
  mutate(
    gap_m = as.numeric(difftime(first_seen,
                                lag(last_seen, default = first(first_seen)),
                                "mins")),
    sess_id = cumsum(gap_m > 45 | row_number() == 1)
  ) %>%
  group_by(bssid, sess_id) %>%
  summarise(
    essid = first(essid),
    start = min(first_seen),
    end   = max(last_seen),
    .groups = "drop"
  ) %>%
  mutate(duration_min = as.numeric(difftime(end, start, "mins"))) %>%
  arrange(desc(duration_min)) %>%
  select(bssid, essid, start, end, duration_min)

print(head(ap_sessions, 10))
cat("Максимальная длительность:", round(max(ap_sessions$duration_min), 1), "мин.\n\n")
```

5. Обнаружить топ-10 самых быстрых точек доступа.

``` {r}
fast_ap <- wifi_ap %>%
  filter(!is.na(speed), speed > 0) %>%
  arrange(desc(speed)) %>%
  slice(1:10) %>%
  select(bssid, essid, speed, chan, pwr)

print(fast_ap)
cat("Максимальная скорость:", max(fast_ap$speed), "Mbps\n")
```

6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.

``` {r}
beacon_stats <- wifi_ap %>%
  mutate(
    hours = as.numeric(difftime(last_seen, first_seen, "hours")),
    rate = ifelse(hours > 0, beacon_count / hours, beacon_count)
  ) %>%
  filter(!is.na(rate), hours > 0, rate > 0) %>%
  arrange(desc(rate)) %>%
  select(bssid, essid, beacon_count, hours, rate, chan)

print(head(beacon_stats, 10))
cat("Максимальная частота:", round(max(beacon_stats$rate), 1), "в час\n")
```

### Данные клиентов 

1. Определить производителя для каждого обнаруженного устройства.

```{r}
client_vendor <- wifi_cl %>%
  mutate(oui = substr(mac, 1, 8)) %>%
  select(mac, oui, probe) %>%
  distinct()

print(head(client_vendor, 10))
cat("Уникальных производителей клиентов:",
    n_distinct(client_vendor$oui), "\n\n")
```

2. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес.

```{r}
cl_nonrnd <- wifi_cl %>%
  mutate(
    second = substr(mac, 2, 2),
    rnd = second %in% c("2", "6", "a", "e", "A", "E")
  ) %>%
  filter(!rnd) %>%
  arrange(desc(pkt)) %>%
  select(mac, first_seen, last_seen, pwr, pkt, probe)

print(head(cl_nonrnd, 10))
cat("Без рандомизации:", nrow(cl_nonrnd), "\n")
cat("Процент:",
    round(100 * nrow(cl_nonrnd) / nrow(wifi_cl), 1), "%\n")
```

3. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.

```{r}
probe_stats <- wifi_cl %>%
  filter(!is.na(probe), probe != "") %>%
  group_by(mac, probe) %>%
  summarise(
    mean_pwr = mean(pwr, na.rm = TRUE),
    sd_pwr = sd(pwr, na.rm = TRUE),
    n = n(),
    first = min(first_seen),
    last  = max(last_seen),
    .groups = "drop"
  ) %>%
  arrange(sd_pwr)

probe_stats
```

4. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.

```{r}
probe_stats <- probe_stats %>%
  mutate(stab = 1 / (sd_pwr + 1e-6))

top_cluster <- probe_stats %>%
  arrange(desc(stab)) %>%
  slice(1)

top_cluster

```

## Оценка результата

  В результате лабораторной работы мы получили знания о методах исследования радиоэлектронной обстановки, составили представление о механизмах работы Wi-Fi сетей, закрепили практические навыки использования языка программирования R и знания основных функций обработки данных экосистемы tidyverse.


## Вывод

  Таким образом, мы научились провоить анализ журналов с использованием программного пакета dplyr.
